#include <stdio.h>

/* Максимален брой върхове в графа */
#define MAXN 200

/* Брой върхове в графа */
const unsigned n = 14;

/* Обхождане в ширина с начало връх v */
const unsigned v = 1;

/* Матрица на съседство на графа */
// 1  2  3  4  5  6  7  8  9 10 11 12 13 14 
const char A[MAXN][MAXN] = {
  {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, // 1
  {1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, // 2 
  {0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, // 3 
  {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, // 4
  {0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}, // 5
  {0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0}, // 6
  {0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0}, // 7
  {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, // 8 <-- queue_p = queue[p]
  {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1}, // 9
  {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0}, // 10
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, // 11
  {0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, // 12
  {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1}, // 13
  {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0}  // 14
};

char used[MAXN];

// Печат на обходнените върхове
void printUsed() {
  unsigned i;
  
  printf("\n");
  printf("1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14\n");
  for (i = 0; i < n; i++) {
    printf("%u, ", used[i]);
  }
  printf("\n");
}

// Печат на опашката
/*
void printQueue() {
  unsigned i;
  
  printf("\n");
  printf("1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14\n");
  for (i = 0; i < n; i++) {
    printf("%u, ", queue[i]);
  }
  printf("\n");
}
*/


/* Функция за обхождане в ширина от даден връх */
void BFS(unsigned i)
{ 
  unsigned k, j; 
  unsigned p; // Използваме я за брояч във вътрешния цикъл
  unsigned queue[MAXN]; // опашка
  unsigned currentVert; // текущ връх
  unsigned levelVertex;
  unsigned queueEnd;
  
  // Инициализация на стойностите на масива за опашка с нула
  for (k = 0; k < n; k++) {
    queue[k] = 0;
  }
  
  // Инициализация на стойностите на масива за обходени върхове с нула
  for (k = 0; k < n; k++) {
    used[k] = 0;
  }
  
  // Маркираме i-я връх като обходен 
  used[i]  = 1; 
  
  // Първоначални параметри на опашката
  queue[0]    = i; // В началото на опашката влиза индекса на i-я връх
  currentVert = 0; // текущ връх
  levelVertex = 1; // ниво на върха = 1
  queueEnd    = 1; // брой на елементите в опашката
   
  // Докато опашката не е празна
  while (currentVert < queueEnd) {
    // Ще циклим от текущия елемент до края на опашката
    
    for (p = currentVert; p < levelVertex; p++) {
      
      // p – вземаме поредния елемент от опашката
      printf("Vertex #%u"      , queue[p]+1); // в опашката държим номера на индекси, а втрхът е с номер индекс+1
      printf("/in queue as #%u", p);
      printf("\n");
      
      currentVert++;
      
      // за всеки необходен наследник j на queue[p], като циклим цял един ред
      for (j = 0; j < n; j++) {
        // Стойност (индекс) на връх, който е в p-тия елеменет на опашката
        unsigned queue_p = queue[p];
        
        if (A[queue_p][j] && !used[j]) {
          // увеличаваме големината на опашката с 1 
          queueEnd++;
          
          // добавяме i-я елемент в края
          queue[queueEnd] = j;
          
          // Обявяваме j-я елемент за използван
          used[j] = 1;
        }
      }
    }
    printf("\n");
    levelVertex = queueEnd;
  }
}

int main(void) {
  printf("Walk peak by peak horizontally %u: \n", v);
  BFS(v-1);
  printUsed();
  return 0;
}
