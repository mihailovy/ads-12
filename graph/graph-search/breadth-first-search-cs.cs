using System;

class Program
{
    // Максимален брой върхове в графа
    const int MAXN = 200;

    // Брой върхове в графа
    const int n = 14;

    // Обхождане в ширина с начало връх v
    const int v = 5;

    // Матрица на съседство на графа
    static readonly int[,] A = new int[n, n]
    {
        {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
        {0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0},
        {0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1},
        {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0},
        {0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1},
        {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0}
    };

    // Масив за маркиране на посетените върхове
    static bool[] used = new bool[MAXN];

    // Функция за обхождане в ширина от даден връх
    static void BFS(int i)
    {
        int[] queue = new int[MAXN]; // Опашка за BFS
        int currentVert = 0; // Текущ връх в опашката
        int levelVertex = 1; // Брой върхове на текущото ниво
        int queueEnd = 1; // Край на опашката

        // Инициализация на опашката и масива used
        for (int k = 0; k < n; k++)
        {
            queue[k] = 0;
            used[k] = false;
        }

        queue[0] = i; // Започваме от началния връх
        used[i] = true;

        while (currentVert < queueEnd) // Докато опашката не е празна
        {
            for (int p = currentVert; p < levelVertex; p++)
            {
                // Вземаме поредния елемент от опашката
                Console.Write((queue[p] + 1) + " ");
                currentVert++;

                // За всеки необходен наследник j на queue[p]
                for (int j = 0; j < n; j++)
                {
                    if (A[queue[p], j] == 1 && !used[j])
                    {
                        queue[queueEnd++] = j; // Добавяме j в опашката
                        used[j] = true; // Маркираме j като посетен
                    }
                }
            }
            Console.WriteLine(); // Нов ред за следващото ниво
            levelVertex = queueEnd; // Актуализираме броя на върховете за следващото ниво
        }
    }

    static void Main(string[] args)
    {
        Console.WriteLine("Walk peak by peak horizontally {0}:", v);
        BFS(v - 1); // Стартираме BFS от връх v-1 (индексирането започва от 0)
    }
}
